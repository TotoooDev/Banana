{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Banana documentation!","text":""},{"location":"#what-is-banana","title":"What is Banana?","text":"<p>Banana is a work-in-progress 3D engine that uses OpenGL for graphics and Lua for scripting.</p>"},{"location":"#get-started","title":"Get started","text":"<p>To get started with Banana, go to the Get Started section.</p>"},{"location":"BananaLua/","title":"BananaLua","text":""},{"location":"BananaLua/#scripts-and-how-to-code-them","title":"Scripts and how to code them","text":"<p>Each entity can have 1 (one) script attached to it. The Lua script must define two functions: <code>OnStart</code> and <code>OnUpdate</code>. To use the Banana engine in your script, you need to import the BananaLua library. The typical script template will look like this:</p> <pre><code>Banana = require \"Banana\" -- Import the Banana library\n\nfunction OnStart()\n    -- This gets called only once when the script is created\nend\n\nfunction OnUpdate(timestep)\n    -- This gets called every scene update\n    -- The timestep argument is the time in seconds passed since the last update\nend\n</code></pre>"},{"location":"BananaLua/#logging","title":"Logging","text":"<p>You can print stuff to the console with the built-in <code>print</code> Lua function, but you can also use you tha Banana alternatives:</p> <pre><code>Banana.LogInfo(\"cool info\")\nBanana.LogWarn(\"cool warning\")\nBanana.LogError(\"not so cool error\")\n</code></pre>"},{"location":"BananaLua/#getting-components","title":"Getting components","text":"<p>You can easily get a component by using the <code>Banana.Get&lt;component_name&gt;</code> function. For example, here is how you can get the transform component of your entity:</p> <pre><code>transform = Banana.GetTransform() -- Get the transform component of the entity\nBanana.LogInfo(transform:GetTranslation()) -- Print the translation\n</code></pre>"},{"location":"components/Transform/","title":"Transform Component","text":"<p>A component that describes the transformation of an entity in space. It is composed of 3 Vec3</p>"},{"location":"components/Transform/#functions","title":"Functions","text":"<ul> <li><code>GetTranslation</code> Returns the translation of the transform.</li> <li><code>GetRotation</code> Returns the rotation of the transform.</li> <li><code>GetScale</code> Returns the scale of the transform.</li> <li><code>SetTranslation(translation)</code> Sets the translation of the transform.</li> <li><code>SetRotation(rotation)</code> Sets the rotation of the transform.</li> <li><code>SetScale(scale)</code> Sets the scale of the transform.</li> </ul>"},{"location":"components/Vec3/","title":"Vec3","text":"<p>A 3D vector.</p>"},{"location":"components/Vec3/#functions","title":"Functions","text":"<ul> <li><code>GetX()</code> Returns the x component of the vector</li> <li><code>GetY()</code> Returns the y component of the vector</li> <li><code>GetZ()</code> Returns the z component of the vector</li> <li><code>SetX(x)</code> Set the x component of the vector</li> <li><code>SetY(y)</code> Sets the y component of the vector</li> <li><code>SetZ(z)</code> Sets the z component of the vector</li> </ul>"},{"location":"get_started/custom_components/","title":"Custom components","text":"<p>Using the Banana-defined components in your can be enough for your game, but at some point your will need to define your own components and bind them to Lua. This is actually very straight-forward, thanks to the BananaLua API (that took me 2 weeks to implement and I'm sure there are still some bugs I hate my life).</p>"},{"location":"get_started/custom_components/#define-a-new-component","title":"Define a new component","text":"<p>This is the simplest part: any data structure (<code>struct</code> and <code>class</code> are the ones you will usually use) can be a component. So to define a new component you just need to define a new class or structure.</p> <p>Create a file named <code>MyComponent.h</code> and define a new class in it:</p> <pre><code>#include &lt;Core/Log.h&gt;\n\nclass MyComponent\n{\npublic:\n    MyComponent(const std::string&amp; message)\n        : m_Message(message)\n    {}\n\n    void PrintMessage()\n    {\n        BANANA_INFO(m_Message);\n    }\n\n    std::string GetMessage()\n    {\n        return m_Message;\n    }\n\nprivate:\n    std::string m_Message;\n}\n</code></pre> <p>Don't forget to regenerate your project by running the <code>GenerateProject</code> script!</p> <p>As you can see, this is a really simple class in C++. Attach it to your entity:</p> <pre><code>auto&amp; customComponent = newEntity.AddComponent&lt;MyComponent&gt;(\"Some cool message\");\n</code></pre> <p>That was the simple part, now we are going to bind the class to Lua.</p>"},{"location":"get_started/custom_components/#lua-bindings","title":"Lua bindings","text":"<p>For this, we will create a static method in <code>MyComponent</code> called <code>Bind</code>. This is where we will send Lua the information about the class.</p> <p>First, include the necessary file at the top:</p> <pre><code>#include &lt;LuaClass.h&gt;\n</code></pre> <p>Then, the static method:</p> <pre><code>static void Bind(lua_State* L)\n{\n    LuaClass&lt;MyComponent&gt; luaClass(L, \"MyComponent\");\n    luaClass.SetConstructor&lt;std::string&gt;();\n    luaClass.SetFunction(\"PrintMessage\", &amp;MyComponent::PrintMessage);\n    luaClass.SetFunction(\"GetMessage\", &amp;MyComponent::GetMessage);\n}\n</code></pre> <p>There is a lot to unpack here, so we will do it in order:</p> <ul> <li>The argument of the method <code>lua_State* L</code> is the global state of your script. It's used to define globals, functions and tables inside of Lua. Usually you we not interact with it directly.</li> <li>First, we define a variable <code>luaClass</code> of type <code>LuaClass&lt;MyComponent&gt;</code>. We pass in the constructor the lua state <code>L</code>, and the name of the component that is used in the script.</li> <li>Then we set a constructor with the <code>SetConstructor</code> method. In the template arguments, we pass the type of the arguments used in the constructor. It can take an argument that is the name of the constructor, which is by default <code>new</code>.</li> <li>Finally we set the methods of the class with the <code>SetFunction</code> method. The first argument is the name of the method in Lua, and the second is the actual function.</li> </ul> <p>Now we just need to call this static function in our scene:</p> <pre><code>MyComponent::Bind(sphereScript.GetState());\n</code></pre> <p>And that's all!</p>"},{"location":"get_started/custom_components/#using-the-component","title":"Using the component","text":"<p>Back in Lua, using a custom component is really easy. All you need is to use it like every other component:</p> <pre><code>myComponent = MyComponent.new(\"Cool message\")\nmessage = myComponent:GetMessage()\nmyComponent:PrintMessage()\n</code></pre> <p>New features are on their way!</p>"},{"location":"get_started/getting_ready/","title":"Getting ready","text":""},{"location":"get_started/getting_ready/#requirements","title":"Requirements","text":"<p>You will need a few things to start using Banana:</p> <ul> <li>Windows or Linux (sorry Apple users).</li> <li>Your favorite text editor</li> <li>A C++17 compiler or IDE (Visual Studio on Windows, make on Linux).</li> <li>git</li> <li>C++ and Lua knowledge.</li> <li>(Optionnal) The Lua interpreter for your system. This is not required but is neat for testing your Lua code is you don't want to launch your whole game.</li> </ul>"},{"location":"get_started/getting_ready/#downloading-banana","title":"Downloading Banana","text":"<p>To start to create your game with Banana, you first need to download Banana from the Github repository. You can do so by running the following command:</p> <p><code>git clone https://github.com/TotoooDev/Banana.git</code>.</p> <p>This will download the whole engine in a folder named <code>Banana</code>. You can rename this folder however you like with your project name.</p>"},{"location":"get_started/getting_ready/#creating-a-project","title":"Creating a project","text":"<p>Go into the folder you've just downloaded. You should find a multitude of files and folders, but the one we are interested in is <code>CreateProject.bat</code> (or <code>CreateProject.sh</code> on Linux). This script will create a new Banana project for you.</p> <p>Launch the script either in a terminal or by double-clicking it. Enter the name of your project, and you will be good to go!</p> <p>The script creates a folder with the name of your project. All your C++ code will live in the folder.</p> <p>If you use Windows, you can simply open the solution file <code>Banana.sln</code> with Visual Studio to begin your project.</p> <p>If you use Linux, simply open the whole folder in your favorite text editor.</p> <p>For the rest of this guide, we will refer to the name of the project as \"GameProject\".</p>"},{"location":"get_started/getting_ready/#project-structure","title":"Project structure","text":"<p>Directories:</p> <ul> <li>The <code>Banana</code> directory is where the engine code is located. Usually you don't need to alter any source files in here.</li> <li>The <code>BananaLua</code> directory is where the bindings between Banana and Lua occur. Again, you don't need to modify anything here.</li> <li>The <code>docs</code> directory contains all the documentation.</li> <li><code>lib</code> contains all the libraries Banana depends on. If you want to add a library, this is where you need to place it (and add it to the <code>premake5.lua</code> file).</li> <li>The <code>bin</code> and <code>bin-intermediate</code> directories are where your binaries are located (the directories are created when you build your project). You can find the executable of your project in the <code>bin/&lt;configuration&gt;-&lt;platform&gt;/&lt;your-project&gt;</code> directory.</li> <li>The <code>dev-assets</code> directory is where you will put all the assets of your game. All the files are copied automatically after your game is built.</li> </ul> <p>Other files:</p> <ul> <li><code>CreateProject</code> is a script that creates a new Banana project.</li> <li><code>GenerateProjects</code> is a script that regenerates all your project files. You need to run it when you add or delete any source file in your project.</li> </ul> <p>You're now ready to read the next section.</p>"},{"location":"get_started/scripts/","title":"Scripts","text":""},{"location":"get_started/scripts/#what-is-a-script","title":"What is a script?","text":"<p>In Banana, a script is a piece of code written in Lua that is interpreted and run by the engine. You can attach them to an entity to alter its behavior while the game is playing.</p>"},{"location":"get_started/scripts/#writing-your-first-script","title":"Writing your first script","text":"<p>Note: This is not a Lua tutorial! You can find a good introduction to the language in the Programming in Lua book.</p> <p>First, create a lua script named <code>script.lua</code> in the <code>dev-assets</code> directory.</p> <p>Every script in Banana must define two functions:</p> <ul> <li><code>OnStart</code>, which is called when the script is created.</li> <li><code>OnUpdate</code>, which is called every scene update.</li> </ul> <p>Let's get scripting!</p> <p>First, at the top of your script, write <code>Banana = require \"Banana\"</code>. This loads the Banana library into a table named <code>Banana</code>. This table is useful to call some Banana function, such as logging.</p> <p>Then, write this piece of code:</p> <pre><code>function OnStart()\n    Banana.LogInfo(\"Hello world!\")\nend\n</code></pre> <p>This defines the <code>OnStart</code> function that logs \"Hello world!\" to the console.</p> <p>Next we will define the <code>OnUpdate</code> function:</p> <pre><code>function OnUpdate(timestep)\n    -- Banana.LogInfo(timestep)\nend\n</code></pre> <p>This function takes one argument <code>timestep</code> which is the amount of time in seconds that has passed since the last update. Here I commented the <code>LogInfo</code> call because I don't want to flood the console with messages.</p> <p>Congratulations, you just created your first script!</p>"},{"location":"get_started/scripts/#attaching-the-script","title":"Attaching the script","text":"<p>Go back to your <code>ExampleScene.h</code> file where you define your entities. We will attach the script to the entity we created earlier, with as usual the <code>AddComponent</code> method:</p> <pre><code>auto&amp; sphereScript = newEntity.AddComponent&lt;LuaScriptComponent&gt;(\"script.lua\");\n</code></pre> <p>We need to pass the name of our script <code>script.lua</code> in the constructor of the component.</p> <p>And that's it! The script is attached to the entity and will be executed by Banana. If you run your game, you should see \"Hello world!\" printed to the console. Try uncommenting the line in <code>OnUpdate</code> to see your console flooded with log messages.</p>"},{"location":"get_started/scripts/#accessing-components-in-scripts","title":"Accessing components in scripts","text":"<p>Printing stuff to the console is cool and all, but it would be way cooler if you could access the components of your entity in your scripts. Fortunately, there is a way to do that!</p> <p>We will write code to access and modify the position of our sphere entity. This is where the <code>Banana</code> table we declared earlier is useful, because we call the <code>Get&lt;component&gt;</code> function from there.</p> <p>First, we need to get access to the transform component that defines the entity in space. This is done with a simple line of code:</p> <pre><code>transform = Banana.GetTransform()\n</code></pre> <p>The variable <code>transform</code> now holds a pointer to a structure containing all the useful information about the transform of our entity. We can access the translation with the <code>GetTranslation</code> method:</p> <pre><code>translation = transform:GetTranslation()\n</code></pre> <p>Here <code>translation</code> is a <code>Vec3</code>, a 3-dimensionnal vector.</p> <p>Now we can move the entity with the <code>GetX</code> and <code>SetX</code> methods of <code>Vec3</code>:</p> <pre><code>x = translation:GetX()\nx += 5 * timestep -- multiply by the timestep to have a constant speed across framerates\ntranslation:SetX(x)\n</code></pre> <p>This is what your <code>OnUpdate</code> function should look like now:</p> <pre><code>function OnUpdate(timestep)\n    -- Banana.LogInfo(timestep)\n    transform = Banana.GetTransform()\n    translation = transform:GetTranslation()\n    x = translation:GetX()\n    x += 5 * timestep -- multiply by the timestep to have a constant speed across framerates\n    translation:SetX(x)\nend\n</code></pre> <p>If you run your game now, you should see your entity moving!</p> <p>By the way, this whole function could be reduced to a single line of code: <code>Banana.GetTransform():GetTranslation():SetX(Banana.GetTransform():GetTranslation():GetX() + 5 * timestep)</code> which is really ugly (but it works lol).</p> <p>You're now ready to read the next section.</p>"},{"location":"get_started/the_first_entity/","title":"Your first entity","text":""},{"location":"get_started/the_first_entity/#what-is-an-entity","title":"What is an entity?","text":"<p>An entity is basically anything in the engine. Your character is an entity, the camera is an entity, even the skybox is represented as an entity.</p> <p>You can attach components to your entities to alter their behavior. For example, the transform component defines the position, rotation and scale in space of your entity.</p> <p>Any data structure can become a component, that means you can define your own components!</p>"},{"location":"get_started/the_first_entity/#what-is-a-scene","title":"What is a scene?","text":"<p>A scene is a container for entities. Every game loop, it executes some operations on the entities depending on their components. For example, for each entity that has the Lua script component, it will execute the <code>OnUpdate</code> function of that script.</p> <p>Every scene has multiple entities, and you can have multiple scene in your project. We will soon see how to change between scenes.</p> <p>Every scene you create must inherit from the <code>Banana::Scene</code> class.</p>"},{"location":"get_started/the_first_entity/#how-to-create-an-entity","title":"How to create an entity","text":"<p>Once you've opened the project, open the <code>ExampleScene.h</code> file in the <code>GameProject</code> folder. It contains a simple example of what a scene may look like.</p> <p>We will modify this scene to render a sphere to the screen. We will need a few things:</p> <ul> <li>An entity with a transform in space and a sphere model.</li> <li>Another entity with a transform in space and a camera.</li> </ul> <p>Let's create the first entity:</p> <pre><code>Banana::Entity newEntity = CreateEntity(\"cool entity\");\n</code></pre> <p>The <code>Scene::CreateEntity</code> method create a new entity with a name in parameter. Every game loop, the new entity will be updated corresponding to its components.</p> <p>Let's add the components to our entity!</p> <pre><code>auto&amp; sphereTransform = newEntity.AddComponent&lt;Banana::TransformComponent&gt;();\nauto&amp; sphereMesh = newEntity.AddComponent&lt;Banana::MeshComponent&gt;(Banana::CreateRef&lt;Banana::Icosphere&gt;(3));\n</code></pre> <p>This attaches a transform component and a mesh component to the new entity. In the mesh component, we pass a reference to an icosphere mesh with 3 subdivisions.</p> <p>The components we just created are stored in the <code>sphereTransform</code> and <code>sphereMesh</code> variables.</p> <p>Let's create our camera:</p> <pre><code>Banana::Entity cam = CreateEntity(\"camera\");\nauto&amp; camTransform = cam.AddComponent&lt;Banana::TransformComponent&gt;();\nauto&amp; camCam = cam.AddComponent&lt;Banana::CameraComponent&gt;(Banana::CreateRef&lt;Banana::Camera&gt;());\n</code></pre> <p>Just like before, we create a new entity and attach the needed components.</p> <p>Next we will see what are scripts and how to use them.</p> <p>You're now ready to read the next section.</p>"}]}